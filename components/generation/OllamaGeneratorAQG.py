import os

import json
import aiohttp

from goldenverba.components.interfaces import Generator


class OllamaGeneratorAQG(Generator):
    def __init__(self):
        super().__init__()
        self.name = "Ollama"
        self.description = "Generator using a local running Ollama Model specified in the ` OLLAMA_MODEL` variable"
        self.requires_env = ["OLLAMA_URL", "OLLAMA_MODEL"]
        self.streamable = True
        self.context_window = 10000

    async def generate_stream(
        self,
        queries: list[str],
        context: list[str],
        conversation: dict = None,
    ):
        """Generate a stream of response dicts based on a list of queries and list of contexts, and includes conversational context
        @parameter: queries : list[str] - List of queries
        @parameter: context : list[str] - List of contexts
        @parameter: conversation : dict - Conversational context
        @returns Iterator[dict] - Token response generated by the Generator in this format {system:TOKEN, finish_reason:stop or empty}.
        """

        url = os.environ.get("OLLAMA_URL", "")
        model = os.environ.get("OLLAMA_MODEL", "")
        if url == "":
            yield {
                "message": "Missing Ollama URL",
                "finish_reason": "stop",
            }

        url += "/api/chat"

        if conversation is None:
            conversation = {}
        messages = self.prepare_messages(queries, context, conversation)

        try:
            data = {"model": model, "messages": messages}
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data) as response:
                    async for line in response.content:
                        if line.strip():  # Ensure line is not just whitespace
                            json_data = json.loads(
                                line.decode("utf-8")
                            )  # Decode bytes to string then to JSON
                            message = json_data.get("message", {}).get("content", "")
                            finish_reason = (
                                "stop" if json_data.get("done", False) else ""
                            )

                            yield {
                                "message": message,
                                "finish_reason": finish_reason,
                            }
                        else:
                            yield {
                                "message": "",
                                "finish_reason": "stop",
                            }

        except Exception:
            raise

    def prepare_messages(
        self, queries: list[str], context: list[str], conversation: dict[str, str]
    ) -> dict[str, str]:
        """
        Prepares a list of messages formatted for a Retrieval Augmented Generation chatbot system, including system instructions, previous conversation, and a new user query with context.

        @parameter queries: A list of strings representing the user queries to be answered.
        @parameter context: A list of strings representing the context information provided for the queries.
        @parameter conversation: A list of previous conversation messages that include the role and content.

        @returns A list of message dictionaries formatted for the chatbot. This includes an initial system message, the previous conversation messages, and the new user query encapsulated with the provided context.

        Each message in the list is a dictionary with 'role' and 'content' keys, where 'role' is either 'system' or 'user', and 'content' contains the relevant text. This will depend on the LLM used.
        """
        base_question_gen = """
            You are an inventive educator dedicated to nurturing critical thinking skills, your task is to devise a series of a number of distinct iterations of a mathematical problem or a textual problem. Each iteration should be rooted in a fundamental problem-solving technique, but feature diverse numerical parameters and creatively reworded text to discourage students from sharing answers. Your objective is to generate a collection of unique questions that not only promote critical thinking but also thwart easy duplication of solutions. Ensure that each variant presents different numerical values, yielding disparate outcomes. Each question should have its noun labels changed. Additionally, each question should stand alone without requiring reference to any other question, although they may share the same solving concept. Your ultimate aim is to fashion an innovative array of challenges that captivate students and inspire analytical engagement.
            
            Strictly follow the following format while providing variants of questions -
            generated_question_variants-
            (all variants generated with proper labelling)

            Examples(I will provide example input prompts and expected responses):
            *Example 1 (Textual):*
            Please generate 3 variants of the question: What is the capital of France?
            generated_question_variants-
            1:In which European country is Paris located?
            2:What is the capital of Italy?
            3:What is the capital of Spain?
            -This is a trivia quiz about geography.

            *Example 2 (Math):*
            Please generate 5 variants of the question: "What is the perimeter of a square if each side measures 5 centimeters?"
            generated_question_variants-
            1. "Find the total length of a rectangle's border if its width is 3 meters and its height is 4 meters."
            2. "Determine the circumference of a circle with a radius of 7 millimeters."
            3. "Calculate the boundary length of an equilateral triangle with each side measuring 8 inches."
            4. "What is the total distance around a polygon with four sides, where one side measures 9 feet and another side measures 12 feet?"
            5. "Discover the perimeter of a rhombus if its diagonal measures 15 centimeters."
            -These are practice problems for basic geometry.
            Explanation: The generated questions are similar to the originals but rephrased using different wording or focusing on a different aspect of the problem (area vs. perimeter, speed vs. time).
        """
        messages = [
            {
                "role": "system",
                "content": base_question_gen,
            }
        ]

        for message in conversation:
            messages.append({"role": message.type, "content": message.content})

        query = " ".join(queries)
        user_context = " ".join(context)

        messages.append(
            {
                "role": "user",
                "content": f"With this provided context: '{user_context}' Follow the task and generate innovative variants: '{query}'",
            }
        )

        return messages
